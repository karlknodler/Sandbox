import pywavefront
import numpy as np
from pathlib import Path
import math
import sys

def _to_float(value):
    if isinstance(value, (int, float)):
        return float(value)
    if isinstance(value, str):
        cleaned = "".join(ch for ch in value if ch.isdigit() or ch in ".-")
        if cleaned:
            return float(cleaned)
    return None


def _building_height_meters(properties):
    levels = _to_float(properties.get("building:levels"))
    if levels is not None and levels > 0:
        return max(8.0, levels * 3.2)

    height = _to_float(properties.get("height"))
    if height is not None and height > 0:
        return max(8.0, height)

    return 18.0


def _extrude_footprint(points_xz, top_y):
    # Remove repeated closing coordinate if present.
    if len(points_xz) > 2 and points_xz[0] == points_xz[-1]:
        points_xz = points_xz[:-1]

    count = len(points_xz)
    if count < 3:
        return [], []

    verts = []
    edges = []

    for x, z in points_xz:
        verts.append((x, 0, z))
    for x, z in points_xz:
        verts.append((x, top_y, z))

    for i in range(count):
        j = (i + 1) % count
        edges.append((i, j))
        edges.append((i + count, j + count))
        edges.append((i, i + count))

    return verts, edges


def load_extruded_geojson_buildings():
    """
    Loads extruded buildings. Coordinates are hardcoded to Sydney (demo requirement).
    """
    sandbox_project = Path(__file__).resolve().parent / "sandbox project"
    if str(sandbox_project) not in sys.path:
        sys.path.append(str(sandbox_project))

    try:
        # keep imports for the Overpass helpers (must exist in sandbox project)
        from geo.bounding_box import bounding_square
        from geo.overpass import fetch_buildings, overpass_to_geojson
    except Exception:
        return []

    # Hardcode to Sydney coordinates (lat, lon)
    lat, lon = -33.8688, 151.2093

    try:
        square = bounding_square(lat, lon, km=1)
        footprints_geojson = overpass_to_geojson(fetch_buildings(square))
    except Exception:
        return []

    meters_per_lat = 111_320
    meters_per_lon = meters_per_lat * math.cos(math.radians(lat))

    buildings_from_geojson = []
    for index, feature in enumerate(footprints_geojson.get("features", []), start=1):
        geometry = feature.get("geometry", {})
        if geometry.get("type") != "Polygon":
            continue

        rings = geometry.get("coordinates", [])
        if not rings:
            continue

        footprint = []
        for coord in rings[0]:
            if len(coord) < 2:
                continue
            point_lon, point_lat = coord[0], coord[1]
            x = (point_lon - lon) * meters_per_lon
            z = (point_lat - lat) * meters_per_lat
            footprint.append((x, z))

        if len(footprint) < 3:
            continue

        top_y = -_building_height_meters(feature.get("properties", {}))
        verts, edges = _extrude_footprint(footprint, top_y)
        if not verts:
            continue

        footprint_points = (
            footprint[:-1] if footprint[0] == footprint[-1] else footprint
        )
        centroid_x = sum(p[0] for p in footprint_points) / len(footprint_points)
        centroid_z = sum(p[1] for p in footprint_points) / len(footprint_points)

        props = feature.get("properties", {})
        address = (
            props.get("addr:full")
            or props.get("name")
            or props.get("addr:housenumber")
            or f"Building {index}"
        )

        buildings_from_geojson.append(
            {
                "pos": [centroid_x, 0, centroid_z],
                "verts": verts,
                "edges": edges,
                "address": address,
            }
        )

    return buildings_from_geojson



# --- simple OBJ exporter (procedural faces) ---
def export_building_pywavefront(verts, edges, file_path):
    file_path = Path(file_path)
    n_total = len(verts)
    if n_total == 0 or n_total % 2 != 0:
        raise ValueError("export_building_pywavefront: unexpected verts length")

    n = n_total // 2
    file_path.parent.mkdir(parents=True, exist_ok=True)

    with file_path.open("w", encoding="utf-8") as f:
        f.write("# Generated by geojsonbuildingextrusion.export_building_pywavefront\n")
        for (x, y, z) in verts:
            f.write(f"v {float(x):.6f} {float(y):.6f} {float(z):.6f}\n")

        # top face (fan)
        top_start = n + 1
        for i in range(1, n - 1):
            a = top_start
            b = top_start + i
            c = top_start + i + 1
            f.write(f"f {a} {b} {c}\n")

        # bottom face (reverse winding)
        for i in range(1, n - 1):
            a = 1
            b = i + 2
            c = i + 1
            f.write(f"f {a} {b} {c}\n")

        # walls (split quad into two triangles)
        for i in range(n):
            i1 = i + 1
            i2 = (i + 1) % n + 1
            ti1 = i1 + n
            ti2 = i2 + n
            f.write(f"f {i1} {i2} {ti2}\n")
            f.write(f"f {i1} {ti2} {ti1}\n")


# --- bridge code (timestamped filenames optional) ---
from datetime import datetime

def generate_and_save_buildings(save_dir="assets/geo_buildings"):
    save_path = Path(save_dir)
    save_path.mkdir(parents=True, exist_ok=True)

    buildings = load_extruded_geojson_buildings()
    if not buildings:
        print("No buildings loaded.")
        return

    run_ts = datetime.utcnow().strftime("%Y%m%d%H%M%S%f")
    for i, building in enumerate(buildings, start=1):
        verts = [(x, -y, z) for x, y, z in building["verts"]]  # flip Y for Ursina
        edges = building["edges"]
        file_path = save_path / f"building_{i}_{run_ts}.obj"
        export_building_pywavefront(verts, edges, file_path)
        print(f"Saved building {i} to {file_path}")